

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sadit.Detector.StoDetector &mdash; SADIT 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="SADIT 1.1.0 documentation" href="../../../index.html" />
    <link rel="up" title="sadit" href="../../sadit.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SADIT 1.1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sadit.html" accesskey="U">sadit</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sadit.Detector.StoDetector</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains all the stochastic detection techniques</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Jing Conan Wang&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s">&quot;wangjing@bu.edu&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s">&quot;Development&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">plt</span>
<span class="c"># try:</span>
<span class="c">#     import matplotlib.pyplot as plt</span>
<span class="c"># except ImportError:</span>
<span class="c">#     plt = False</span>
<span class="c"># import csv</span>


<span class="kn">from</span> <span class="nn">DetectorLib</span> <span class="kn">import</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">DataEndException</span><span class="p">,</span> <span class="n">FetchNoDataException</span><span class="p">,</span> <span class="n">abstract_method</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="n">save_csv</span>
<span class="kn">from</span> <span class="nn">mod_util</span> <span class="kn">import</span> <span class="n">plot_points</span>

<span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="c"># import argparse</span>
<span class="c"># from Base import BaseDetector</span>
<span class="kn">from</span> <span class="nn">Base</span> <span class="kn">import</span> <span class="n">WindowDetector</span>

<span class="c"># def run_until_data_end(func, parameters):</span>
<span class="c">#     for para in parameters:</span>
<span class="c">#         try:</span>
<span class="c">#             yield func(*para)</span>
<span class="c">#         except FetchNoDataException:</span>
<span class="c">#             break #FIXME</span>
<span class="c">#         except DataEndException as e:</span>
<span class="c">#             raise e</span>

<div class="viewcode-block" id="StoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector">[docs]</a><span class="k">class</span> <span class="nc">StoDetector</span> <span class="p">(</span><span class="n">WindowDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Abstract Base Class for stochastic anomaly detector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    - desc: dict</span>
<span class="sd">            Dictionary of default parameters</span>

<span class="sd">        + normal_rg : list</span>
<span class="sd">                range of normal traffic, if</span>
<span class="sd">        + win_type :</span>
<span class="sd">        + max_detect_num</span>
<span class="sd">        + interval</span>
<span class="sd">        + fea_option</span>
<span class="sd">        + entropy_th</span>
<span class="sd">        + hoeff_far</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">desc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">entropy</span><span class="o">=</span><span class="p">[],</span> <span class="n">winT</span><span class="o">=</span><span class="p">[],</span> <span class="n">threshold</span><span class="o">=</span><span class="p">[],</span> <span class="n">em</span><span class="o">=</span><span class="p">[])</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="StoDetector.get_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.get_em">[docs]</a>    <span class="k">def</span> <span class="nf">get_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;abstract method. Get empirical measure,</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------</span>
<span class="sd">        rg : list</span>
<span class="sd">                specify the start and the end point of the data that will be</span>
<span class="sd">                used.</span>
<span class="sd">        rg_type :  {&#39;flow&#39;, &#39;time&#39;}</span>
<span class="sd">                type of the rg.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">abstract_method</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="StoDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add parameters</span>

<span class="sd">        entropy_th specify the threshold manually.</span>
<span class="sd">        hoeff_far and ccoef are the parameter of hoeffding threshold rule.</span>
<span class="sd">        Increase hoeff_far will decrease threshold</span>
<span class="sd">        Increase ccoef will increase threshold</span>
<span class="sd">        A small window size will make hoeff_far play more role, while a larger</span>
<span class="sd">        window size will let ccoef more significant.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StoDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">init_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--hoeff_far&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;false alarm rate for hoeffding rule, if this parameter is set while</span>
<span class="s">                entropy_th parameter is not set, will calculate threshold according to</span>
<span class="s">                hoeffding rule. Increase hoeff_far will decrease threshold&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--entropy_th&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&#39;entropy threshold to determine the anomaly, has </span><span class="se">\</span>
<span class="s">                higher priority than hoeff_far&#39;</span><span class="p">)</span>

        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--ccoef&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;correction coefficient for calculat threshold using hoeffding rule.</span>
<span class="s">                hoeffding threshold is only a asymotical result. An O(n) linear term has been</span>
<span class="s">                abandon during the analysis, however, it practice, this term is important. You</span>
<span class="s">                need run on some test data set to deterine an approraite correction coefficient</span>
<span class="s">                first. Increase ccoef will increase threshold.</span>
<span class="s">                &quot;&quot;&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="StoDetector.I"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.I">[docs]</a>    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em1</span><span class="p">,</span> <span class="n">em2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; calculate the K-L divergence of two emperical measures</span>

<span class="sd">        [abstract method]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">abstract_method</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="StoDetector.get_flow_num"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.get_flow_num">[docs]</a>    <span class="k">def</span> <span class="nf">get_flow_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">):</span>
        <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_get_where</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">+</span><span class="n">win_size</span><span class="p">],</span> <span class="n">rg_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ep</span> <span class="o">-</span> <span class="n">sp</span>
</div>
<div class="viewcode-block" id="StoDetector.record"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.record">[docs]</a>    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="StoDetector.reset_record"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.reset_record">[docs]</a>    <span class="k">def</span> <span class="nf">reset_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</div>
<div class="viewcode-block" id="StoDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nominal_rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;normal_rg&#39;</span><span class="p">]</span>
        <span class="c"># import pdb;pdb.set_trace()</span>
        <span class="n">rg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="n">nominal_rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="o">=</span><span class="n">rg_type</span><span class="p">)</span>

    <span class="c"># def detect(self, data_file, nominal_rg = [0, 1000], rg_type=&#39;time&#39;,  max_detect_num=None):</span></div>
<div class="viewcode-block" id="StoDetector.detect"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.detect">[docs]</a>    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; main function to detect.</span>

<span class="sd">        it will slide the window, get the emperical measure and get the</span>
<span class="sd">        indicator</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------------</span>
<span class="sd">        data_file : subclass of **DataHandler**.</span>
<span class="sd">                See DataHandler.py.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------------</span>
<span class="sd">        record_data: dict</span>
<span class="sd">                + desc : parameters used in the detection</span>
<span class="sd">                + threshold : threshold</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># nominal_rg = self.desc[&#39;normal_rg&#39;]</span>
        <span class="n">rg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="n">max_detect_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;max_detect_num&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span> <span class="o">=</span> <span class="n">data_file</span>
        <span class="c"># self.norm_em = self.get_em(rg=nominal_rg, rg_type=rg_type)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">()</span>
        <span class="c"># self.desc[&#39;norm_em&#39;] = self.norm_em</span>

        <span class="n">win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;interval&#39;</span><span class="p">]</span>

        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;fr_win_size&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="s">&#39;flow_rate&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;fea_option&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">max_detect_num</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_detect_num</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">rg_type</span> <span class="o">==</span> <span class="s">&#39;time&#39;</span> <span class="p">:</span> <span class="k">print</span> <span class="s">&#39;time: </span><span class="si">%f</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;flow: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="n">win_size</span><span class="p">]</span> <span class="c"># For two window method</span>
                <span class="n">em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="p">[</span><span class="n">time</span><span class="p">,</span> <span class="n">time</span><span class="o">+</span><span class="n">win_size</span><span class="p">],</span> <span class="n">rg_type</span><span class="o">=</span><span class="n">rg_type</span><span class="p">)</span>
                <span class="n">entropy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">em</span><span class="p">,</span> <span class="n">norm_em</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_em</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span> <span class="n">entropy</span><span class="o">=</span><span class="n">entropy</span><span class="p">,</span> <span class="n">winT</span> <span class="o">=</span> <span class="n">time</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">em</span><span class="o">=</span><span class="n">em</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">FetchNoDataException</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;there is no data to detect in this window&#39;</span>
            <span class="k">except</span> <span class="n">DataEndException</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;reach data end, break&#39;</span>
                <span class="k">break</span>

            <span class="n">time</span> <span class="o">+=</span> <span class="n">interval</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">detect_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c"># import pdb;pdb.set_trace()</span>

        <span class="c"># get the threshold:</span>
        <span class="c"># if self.args.entropy_th is not None:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;entropy_th&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># import pdb;pdb.set_trace()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">entropy_th</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">detect_num</span>
        <span class="c"># elif self.args.hoeff_far is not None:</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hoeff_far&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hoeffding_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;hoeff_far&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># record the parameters</span>
        <span class="c"># self.record_data[&#39;args&#39;] = self.args</span>
        <span class="c"># self.record_data[&#39;desc&#39;] = tuple(self.desc.items())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;desc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span>
</div>
<div class="viewcode-block" id="StoDetector.hoeffding_rule"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.hoeffding_rule">[docs]</a>    <span class="k">def</span> <span class="nf">hoeffding_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">false_alarm_rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; hoeffding rule with linear correction term</span>

<span class="sd">        Parameters:</span>
<span class="sd">        --------------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of flows in the window</span>
<span class="sd">        false_alarm_rate : float</span>
<span class="sd">            false alarm rate</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------</span>
<span class="sd">        ht : float</span>
<span class="sd">            hoeffding threshold</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># return -1.0 / n * log(false_alarm_rate) + self.desc[&#39;ccoef&#39;] * log(n) / n</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">false_alarm_rate</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;ccoef&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span>
</div>
<div class="viewcode-block" id="StoDetector.get_hoeffding_threshold"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.get_hoeffding_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">get_hoeffding_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_alarm_rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;calculate the threshold of hoeffiding rule,</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        false_alarm_rate : float</span>
<span class="sd">            false alarm rate</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------------</span>
<span class="sd">        res : list</span>
<span class="sd">            list of thresholds for each window.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ----------------</span>
<span class="sd">        :math: `threshold = -1 / |G| log(epsilon)` where |G| is the number of flows in</span>
<span class="sd">        the window and `epsilon` is the false alarm_rate</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detect_num</span><span class="p">):</span>
            <span class="n">flow_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_seq</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">flow_num_in_win</span> <span class="o">=</span> <span class="n">flow_seq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">flow_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hoeffding_rule</span><span class="p">(</span><span class="n">flow_num_in_win</span><span class="p">,</span> <span class="n">false_alarm_rate</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="k">def</span> <span class="nf">_get_flow_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">win_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the starting and ending sequence number of all flows in this window</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;interval&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rg_type</span> <span class="o">==</span> <span class="s">&#39;time&#39;</span><span class="p">:</span>
            <span class="c"># import pdb;pdb.set_trace()</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;winT&#39;</span><span class="p">][</span><span class="n">win_idx</span><span class="p">]</span>
            <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_get_where</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">+</span><span class="n">win_size</span><span class="p">],</span> <span class="n">rg_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rg_type</span> <span class="o">==</span> <span class="s">&#39;flow&#39;</span><span class="p">:</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">interval</span> <span class="o">*</span> <span class="n">win_idx</span>
            <span class="n">ep</span> <span class="o">=</span> <span class="n">interval</span> <span class="o">*</span> <span class="p">(</span><span class="n">win_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;unknow rg type&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span>

    <span class="c"># def plot(self, far=None, *args, **kwargs):</span>
<div class="viewcode-block" id="StoDetector.plot"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  plot the detection result</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        See plot_points</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;winT&#39;</span><span class="p">]</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">]</span>
        <span class="c"># import pdb;pdb.set_trace()</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>
        <span class="n">plot_points</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ep</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                <span class="n">xlabel_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">],</span> <span class="n">ylabel_</span><span class="o">=</span> <span class="s">&#39;entropy&#39;</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="StoDetector.dump"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_name</span><span class="p">):</span>
        <span class="c"># import ipdb;ipdb.set_trace()</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="p">)</span>
        <span class="c"># pickle.dump(self.__dict__, open(data_name, &#39;w&#39;) )</span>
</div>
<div class="viewcode-block" id="StoDetector.plot_dump"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.plot_dump">[docs]</a>    <span class="k">def</span> <span class="nf">plot_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;plot dumped data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">data_name</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">))</span>
        <span class="c"># data = pickle.load(open(data_name, &#39;r&#39;))</span>
        <span class="c"># self.__dict__.update(data)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="StoDetector.find_abnormal_windows"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.find_abnormal_windows">[docs]</a>    <span class="k">def</span> <span class="nf">find_abnormal_windows</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="n">entropy_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; find abnormal windows out of all windows</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -----------</span>
<span class="sd">        entropy_threshold : list of floats</span>
<span class="sd">            list of threshold for each window</span>
<span class="sd">        ab_win_portion</span>
<span class="sd">            portion of windows considered as abnormal</span>
<span class="sd">        ab_win_num : int</span>
<span class="sd">            abnormal window number</span>

<span class="sd">        Notes</span>
<span class="sd">        -----------</span>
<span class="sd">        find abnormal windows. There are three standards to select abnormal windows:</span>
<span class="sd">            1. when the entropy &gt;= entropy_threshold. when entropy_threshold is a list. the length of entropy_threshold should</span>
<span class="sd">                equals the length of entropy. The element in this list is the entropy threshold for window with corresponding position.</span>
<span class="sd">            2. when it is winthin the top *portion* of entropy, 0 &lt;= *portion* &lt;= 1</span>
<span class="sd">            3. when it is the top *sel_num* of entropy</span>
<span class="sd">        the priority of 1 &gt; 2 &gt; 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entropy</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">entropy_threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ab_win_portion</span><span class="p">:</span>
                <span class="n">ab_win_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">num</span> <span class="o">*</span> <span class="n">ab_win_portion</span> <span class="p">)</span>
            <span class="n">sorted_entropy</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">entropy</span><span class="p">)</span>
            <span class="n">entropy_threshold</span> <span class="o">=</span> <span class="n">sorted_entropy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">ab_win_num</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entropy_threshold</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">entropy_threshold</span><span class="p">)</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">entropy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">entropy_threshold</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">entropy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">entropy_threshold</span> <span class="p">]</span>
</div>
<div class="viewcode-block" id="StoDetector.export_ab_flow_entropy"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.StoDetector.export_ab_flow_entropy">[docs]</a>    <span class="k">def</span> <span class="nf">export_ab_flow_entropy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entropy</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span>
            <span class="n">entropy_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;export abnormal flows based on entropy</span>

<span class="sd">        Parameters</span>
<span class="sd">        --------------</span>
<span class="sd">        entropy : list</span>
<span class="sd">            a list of entropy, one number for each window</span>
<span class="sd">        fname : str,</span>
<span class="sd">            file name of the output abnormal flow</span>
<span class="sd">        entropy_threshold, ab_win_portion : str, optional</span>
<span class="sd">            criterion to identifi abnormal window, see docs of</span>
<span class="sd">            *find_abnormal_windows* for detailed meaning</span>
<span class="sd">        ab_win_num : int, optional</span>
<span class="sd">            criterion to identifi abnormal window, see docs of</span>
<span class="sd">            *find_abnormal_windows* for detailed meaning</span>

<span class="sd">        Returns</span>
<span class="sd">        --------------</span>
<span class="sd">        None</span>

<span class="sd">        Notes</span>
<span class="sd">        ----------------</span>
<span class="sd">        - abnormal windows are identifed.</span>
<span class="sd">        - all flows in those windows are exported as abnormal flows.</span>
<span class="sd">        - self.data_file.data._get_where() is used in current version, which</span>
<span class="sd">          should be fixed in the future</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ab_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_abnormal_windows</span><span class="p">(</span><span class="n">entropy</span><span class="p">,</span> <span class="n">entropy_threshold</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="p">)</span>

        <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">rg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;interval&#39;</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ab_idx</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">st</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;winT&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">rg_type</span> <span class="o">==</span> <span class="s">&#39;time&#39;</span> <span class="k">else</span> <span class="p">(</span><span class="n">interval</span> <span class="o">*</span> <span class="n">idx</span><span class="p">)</span>
            <span class="c"># import pdb;pdb.set_trace()</span>
            <span class="c"># data, _ = self.data_file.get_fea_slice([st, st+win_size], rg_type)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">get_fea_slice</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">+</span><span class="n">win_size</span><span class="p">],</span> <span class="n">rg_type</span><span class="p">)</span>
            <span class="n">sp</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_get_where</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">+</span><span class="n">win_size</span><span class="p">],</span> <span class="n">rg_type</span><span class="p">)</span> <span class="c">#FIXME</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Seq # [</span><span class="si">%i</span><span class="s">] for abnormal window: [</span><span class="si">%i</span><span class="s">], entropy: [</span><span class="si">%f</span><span class="s">], start time [</span><span class="si">%f</span><span class="s">]</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entropy</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">st</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">data_str</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> - </span><span class="si">%f</span><span class="s">&#39;</span><span class="o">%</span><span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">get_fea_list</span><span class="p">(),</span> <span class="n">l</span><span class="p">)]</span> <span class="p">)</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Sample # </span><span class="si">%i</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data_str</span><span class="p">))</span>

        <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="ModelFreeAnoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelFreeAnoDetector">[docs]</a><span class="k">class</span> <span class="nc">ModelFreeAnoDetector</span><span class="p">(</span><span class="n">StoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Model Free approach, use I.I.D Assumption</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ModelFreeAnoDetector.I"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelFreeAnoDetector.I">[docs]</a>    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">norm_em</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">I1</span><span class="p">(</span><span class="n">em</span><span class="p">,</span> <span class="n">norm_em</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelFreeAnoDetector.get_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelFreeAnoDetector.get_em">[docs]</a>    <span class="k">def</span> <span class="nf">get_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get empirical measure&quot;&quot;&quot;</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">)</span>
        <span class="c"># return pmf, Pmb, mpmb</span>
        <span class="k">return</span> <span class="n">pmf</span>
</div></div>
<div class="viewcode-block" id="ModelBaseAnoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelBaseAnoDetector">[docs]</a><span class="k">class</span> <span class="nc">ModelBaseAnoDetector</span><span class="p">(</span><span class="n">StoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Model based approach, use Markovian Assumption</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ModelBaseAnoDetector.I"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelBaseAnoDetector.I">[docs]</a>    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">norm_em</span><span class="p">):</span>
        <span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span> <span class="o">=</span> <span class="n">em</span>
        <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="n">norm_em</span>
        <span class="k">return</span> <span class="n">I2</span><span class="p">(</span><span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ModelBaseAnoDetector.get_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.ModelBaseAnoDetector.get_em">[docs]</a>    <span class="k">def</span> <span class="nf">get_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">):</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span>

</div></div>
<span class="kn">from</span> <span class="nn">Ident</span> <span class="kn">import</span> <span class="o">*</span>
<div class="viewcode-block" id="FBAnoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector">[docs]</a><span class="k">class</span> <span class="nc">FBAnoDetector</span><span class="p">(</span><span class="n">StoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;model free and model based together, will be faster then run model free</span>
<span class="sd">    and model based approaches separately since some intemediate results are reused.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FBAnoDetector.I"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.I">[docs]</a>    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">norm_em</span><span class="p">):</span>
        <span class="n">d_pmf</span><span class="p">,</span> <span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span> <span class="o">=</span> <span class="n">em</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="n">norm_em</span>
        <span class="k">return</span> <span class="n">I1</span><span class="p">(</span><span class="n">d_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FBAnoDetector.get_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.get_em">[docs]</a>    <span class="k">def</span> <span class="nf">get_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get empirical measure&quot;&quot;&quot;</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span>
</div>
<div class="viewcode-block" id="FBAnoDetector.plot"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">far</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">figure_</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">subplot_</span><span class="o">=</span><span class="p">(</span><span class="mi">211</span><span class="p">,</span> <span class="mi">212</span><span class="p">),</span> <span class="n">title_</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;model free&#39;</span><span class="p">,</span> <span class="s">&#39;model based&#39;</span><span class="p">],</span>
            <span class="n">pic_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pic_show</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">csv</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_plot_as_csv</span><span class="p">()</span>

        <span class="n">rt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;winT&#39;</span><span class="p">]</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">mb</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">])</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">csv</span><span class="p">:</span>
            <span class="n">save_csv</span><span class="p">(</span><span class="n">csv</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;rt&#39;</span><span class="p">,</span> <span class="s">&#39;mf&#39;</span><span class="p">,</span> <span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;threshold&#39;</span><span class="p">],</span> <span class="n">rt</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">figure_</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">figure_</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="c"># import ipdb;ipdb.set_trace()</span>
        <span class="n">plot_points</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                <span class="n">figure_</span> <span class="o">=</span> <span class="n">figure_</span><span class="p">,</span>
                <span class="n">xlabel_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">],</span> <span class="n">ylabel_</span><span class="o">=</span> <span class="s">&#39;entropy&#39;</span><span class="p">,</span>
                <span class="n">subplot_</span> <span class="o">=</span> <span class="n">subplot_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">title_</span> <span class="o">=</span> <span class="n">title_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">pic_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pic_show</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">plot_points</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span>
                <span class="n">figure_</span> <span class="o">=</span> <span class="n">figure_</span><span class="p">,</span>
                <span class="n">xlabel_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">],</span> <span class="n">ylabel_</span><span class="o">=</span> <span class="s">&#39;entropy&#39;</span><span class="p">,</span>
                <span class="n">subplot_</span> <span class="o">=</span> <span class="n">subplot_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">title_</span> <span class="o">=</span> <span class="n">title_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">pic_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pic_show</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pic_name</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">pic_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pic_show</span><span class="p">:</span> <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="FBAnoDetector.export_abnormal_flow"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.export_abnormal_flow">[docs]</a>    <span class="k">def</span> <span class="nf">export_abnormal_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">entropy_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">ab_win_portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; export the abnormal flows for abnormal windows</span>

<span class="sd">        based on model_free entropy and model_based entropy</span>

<span class="sd">        See Also</span>
<span class="sd">        ---------------</span>
<span class="sd">        see **StoDetector.export_ab_flow_entropy** for the meaning of the</span>
<span class="sd">        parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">mb</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">])</span>
        <span class="c"># select portion of the window to be abnormal</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

        <span class="c"># for model free entropy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export_ab_flow_entropy</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dirname</span> <span class="o">+</span> <span class="s">&#39;/mf-&#39;</span> <span class="o">+</span> <span class="n">basename</span><span class="p">,</span>
                <span class="n">entropy_threshold</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="p">)</span>

        <span class="c"># for model based entropy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">export_ab_flow_entropy</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">dirname</span> <span class="o">+</span> <span class="s">&#39;/mb-&#39;</span> <span class="o">+</span> <span class="n">basename</span><span class="p">,</span>
                <span class="n">entropy_threshold</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FBAnoDetector.get_ab_flow_seq"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.get_ab_flow_seq">[docs]</a>    <span class="k">def</span> <span class="nf">get_ab_flow_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">entropy_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">ab_win_portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">ab_flow_info</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="c"># ab_flow_state=None, ab_flow_tran=None):</span>
        <span class="sd">&quot;&quot;&quot;get abnormal flow sequence number.</span>

<span class="sd">        the input is citerions which window will be abnormal window</span>

<span class="sd">        Parameters:</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        entropy_type : {&#39;mf&#39;, &#39;mb&#39;}</span>
<span class="sd">            type of entropy</span>
<span class="sd">        entropy_threshold : list of floats</span>
<span class="sd">            list of thresholds, each for a window.</span>
<span class="sd">        ab_win_portion : float</span>
<span class="sd">            portion of windows that will be considered as abnormal</span>
<span class="sd">        ab_win_num :</span>
<span class="sd">            number of windows that will be considered as abnormal</span>
<span class="sd">        ab_flow_info : list</span>
<span class="sd">            represents either abnormal flow state(for model free approach) and</span>
<span class="sd">            abnormal flow trantision pair(for model based approach).</span>

<span class="sd">        Returns:</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        ano_flow_seq : list of ints</span>
<span class="sd">            a list of sequence for flows that will be considered as abnormal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># assert( (ab_flow_state and not ab_flow_tran) or (not ab_flow_state and ab_flow_tran) )</span>
        <span class="c"># if ab_flow_tran: # set the flow_state be the set of all</span>
            <span class="c"># ab_flow_state = set.union(set([tran[0] for tran in ab_flow_tran]), [tran[1] for tran in ab_flow_tran])</span>

        <span class="n">mf</span><span class="p">,</span> <span class="n">mb</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">])</span>
        <span class="n">ab_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_abnormal_windows</span><span class="p">(</span><span class="nb">locals</span><span class="p">()[</span><span class="n">entropy_type</span><span class="p">],</span> <span class="n">entropy_threshold</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="p">)</span>
        <span class="c"># ab_idx = self.find_abnormal_windows(mf, entropy_threshold, ab_win_portion, ab_win_num)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ab_win_idx</span> <span class="o">=</span> <span class="n">ab_idx</span>
        <span class="n">ano_flow_seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ab_idx</span><span class="p">:</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">ed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_seq</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="c"># only select those flows belongs to</span>
            <span class="c"># abnormal flow stat or abnormal flow trainsition</span>
            <span class="c"># rg_type = self.desc[&#39;win_type&#39;]</span>
            <span class="c"># quan_level = self.data_file._quantize_fea([st, ed], rg_type=&#39;flow&#39;)</span>
            <span class="n">quan_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_file</span><span class="o">.</span><span class="n">hash_quantized_fea</span><span class="p">([</span><span class="n">st</span><span class="p">,</span> <span class="n">ed</span><span class="p">],</span> <span class="n">rg_type</span><span class="o">=</span><span class="s">&#39;flow&#39;</span><span class="p">)</span> <span class="c"># TODO, st, ed is alread flow idx, so use &#39;flow&#39; as rg_type</span>
            <span class="c"># if ab_flow_state:</span>
            <span class="k">if</span> <span class="n">ab_flow_info</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ano_flow_seq</span> <span class="o">+=</span> <span class="nb">range</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">ed</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ab_flow_info</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s">&#39;mf&#39;</span><span class="p">:</span>
                <span class="n">win_ab_flow_seq</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">st</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ed</span><span class="o">-</span><span class="n">st</span><span class="p">)</span> <span class="k">if</span> <span class="n">quan_level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ab_flow_info</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ano_tran_set</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">st</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ed</span><span class="o">-</span><span class="n">st</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">quan_level</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">quan_level</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">ab_flow_info</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ano_tran_set</span><span class="p">:</span>
                    <span class="n">win_ab_flow_seq_raw</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">flow_states</span><span class="p">)</span> <span class="k">for</span> <span class="n">flow_states</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ano_tran_set</span><span class="p">)]</span>
                    <span class="n">win_ab_flow_seq</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">win_ab_flow_seq_raw</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">win_ab_flow_seq</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">ano_flow_seq</span> <span class="o">+=</span> <span class="n">win_ab_flow_seq</span>

        <span class="k">return</span> <span class="n">ano_flow_seq</span>
</div>
<div class="viewcode-block" id="FBAnoDetector.ident"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.FBAnoDetector.ident">[docs]</a>    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident_type</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">,</span> <span class="n">portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_states_num</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">entropy_threshold</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Identificate the anomalous flow state or flow transition pair</span>

<span class="sd">        Parameters:</span>
<span class="sd">        --------------------------------</span>
<span class="sd">        ident_type : {&#39;FlowStateIdent&#39;, &#39;ComponentFlowStateIdent&#39;,</span>
<span class="sd">            &#39;DerivativeFlowStateIdent&#39;, &#39;FlowPairIdent&#39;, &#39;componentflowpairident&#39;,</span>
<span class="sd">            &#39;DerivativeFlowPairIdent&#39;}</span>
<span class="sd">        entropy_type : {&#39;mf&#39;, &#39;mb&#39;}.</span>
<span class="sd">                &#39;mf&#39; will identify the flow state</span>
<span class="sd">                &#39;mb&#39; will identify the flow transition pair.</span>
<span class="sd">        portion : float</span>
<span class="sd">                portion of flow state that will be selected as anomalous.</span>
<span class="sd">        ab_states_num : int</span>
<span class="sd">                the number of flow states that will be selected as anomalous.</span>


<span class="sd">        Returns:</span>
<span class="sd">        ---------------------------------------</span>
<span class="sd">            res : list</span>
<span class="sd">                if ident_type is a FlowStateIdent type, each element in the</span>
<span class="sd">                    `res` is the sequence of identifed flow states. Otherwise,</span>
<span class="sd">                    each element in `res` is a two element pair</span>
<span class="sd">                    (from_state_idx, to_state_idx)</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------------------------------</span>
<span class="sd">        - *ident_type* can be any Identification Class in Ident.py</span>
<span class="sd">        - **portion** has higher priority</span>
<span class="sd">            than **ab_states_num**</span>
<span class="sd">        - 1. first the abnormal window indices are identified. 2. according to</span>
<span class="sd">          ident_type, some flows in the abnormal window indices are exported.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">em_record_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;em&#39;</span><span class="p">]</span>
        <span class="k">def</span> <span class="nf">tran_to_joint</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">mar</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            Parameters:</span>
<span class="sd">            ---------------</span>
<span class="sd">                tp : list of list</span>
<span class="sd">                    transition probability</span>
<span class="sd">                mar : list</span>
<span class="sd">                    margin probability</span>

<span class="sd">            Returns:</span>
<span class="sd">            --------------</span>
<span class="sd">                res : list</span>
<span class="sd">                    joint probability distribution</span>


<span class="sd">            Notes:</span>
<span class="sd">            --------------</span>
<span class="sd">                joint_prob[a][b] = tp[a][b] * mar[p]</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tp</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span><span class="n">mar</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">m</span><span class="o">*</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tp</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">def</span> <span class="nf">get_nu_set</span><span class="p">(</span><span class="n">em_record_set</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;  get empirical measure according to entropy_type</span>

<span class="sd">            Parameters:</span>
<span class="sd">            ---------------</span>
<span class="sd">                em_record_set : list</span>
<span class="sd">                    result</span>
<span class="sd">                entropy_type : {&#39;mf&#39;, &#39;mb&#39;}</span>

<span class="sd">            Returns:</span>
<span class="sd">            --------------</span>
<span class="sd">            res : list</span>
<span class="sd">                if entropy_type == &#39;mf&#39;, return model-free empirical measure</span>
<span class="sd">                if entropy_type == &#39;mb&#39;, return model-based empirical measure</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s">&#39;mf&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">em</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">em</span> <span class="ow">in</span> <span class="n">em_record_set</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">entropy_type</span> <span class="o">==</span> <span class="s">&#39;mb&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">tran_to_joint</span><span class="p">(</span><span class="n">em</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">em</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">em</span> <span class="ow">in</span> <span class="n">em_record_set</span><span class="p">]</span>

        <span class="n">nu_set</span> <span class="o">=</span> <span class="n">get_nu_set</span><span class="p">(</span><span class="n">em_record_set</span><span class="p">,</span> <span class="n">entropy_type</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">get_nu_set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_em</span><span class="p">],</span> <span class="n">entropy_type</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">ident_type</span><span class="p">](</span><span class="n">nu_set</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">mf</span><span class="p">,</span> <span class="n">mb</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">record_data</span><span class="p">[</span><span class="s">&#39;entropy&#39;</span><span class="p">])</span>
        <span class="n">ab_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_abnormal_windows</span><span class="p">(</span><span class="nb">locals</span><span class="p">()[</span><span class="n">entropy_type</span><span class="p">],</span>
                <span class="n">entropy_threshold</span><span class="p">,</span> <span class="n">ab_win_portion</span><span class="p">,</span> <span class="n">ab_win_num</span><span class="p">)</span>
        <span class="n">ident</span><span class="o">.</span><span class="n">set_detect_result</span><span class="p">([(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ab_idx</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nu_set</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">ident</span><span class="o">.</span><span class="n">filter_states</span><span class="p">(</span><span class="n">ab_idx</span><span class="p">,</span> <span class="n">portion</span><span class="p">,</span> <span class="n">ab_states_num</span><span class="p">)</span>


    <span class="c"># def get_ab_flow_seq_mb(self, entropy_threshold=None, ab_win_portion=None, ab_win_num=None):</span>
        <span class="c"># mf, mb = zip(*self.record_data[&#39;entropy&#39;])</span>
        <span class="c"># ab_idx = self.find_abnormal_windows(mb, entropy_threshold, ab_win_portion, ab_win_num)</span>
        <span class="c"># ano_flow_seq = []</span>
        <span class="c"># for idx in ab_idx:</span>
            <span class="c"># st, ed = self._get_flow_seq(idx)</span>
            <span class="c"># ano_flow_seq += range(st, ed)</span>

        <span class="c"># return ano_flow_seq</span>

    <span class="c"># def get_ab_flow_seq(self, entropy_threshold=None, ab_win_portion=None, ab_win_num=None):</span>
    <span class="c">#     mf, mb = zip(*self.record_data[&#39;entropy&#39;])</span>
    <span class="c">#     ab_idx = self.find_abnormal_windows(mf, entropy_threshold, ab_win_portion, ab_win_num)</span>
    <span class="c">#     ano_flow_seq = []</span>
    <span class="c">#     for idx in ab_idx:</span>
    <span class="c">#         st, ed = self._get_flow_seq(idx)</span>
    <span class="c">#         ano_flow_seq += range(st, ed)</span>

    <span class="c">#     return ano_flow_seq</span>
</div></div>
<div class="viewcode-block" id="SlowDriftStaticDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.SlowDriftStaticDetector">[docs]</a><span class="k">class</span> <span class="nc">SlowDriftStaticDetector</span><span class="p">(</span><span class="n">FBAnoDetector</span><span class="p">):</span>
<div class="viewcode-block" id="SlowDriftStaticDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.SlowDriftStaticDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--start&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;start point of the normal traffic&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--delta_t&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;delta_t is a small time range during which the normal</span>
<span class="s">                behavior is considered unchanged&quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SlowDriftStaticDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.SlowDriftStaticDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;start&#39;</span><span class="p">]</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;delta_t&#39;</span><span class="p">]</span>
        <span class="n">win_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="n">normal_rg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;normal_rg&#39;</span><span class="p">]</span>

        <span class="n">rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">delta_t</span><span class="p">]</span>
        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="n">normal_rg</span><span class="p">,</span><span class="n">rg_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">norm_win_em</span>
</div></div>
<div class="viewcode-block" id="PeriodStaticDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStaticDetector">[docs]</a><span class="k">class</span> <span class="nc">PeriodStaticDetector</span><span class="p">(</span><span class="n">FBAnoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Static Methods</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="PeriodStaticDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStaticDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeriodStaticDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">init_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--start&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;start point of the period selection&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--period&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;the period of underlying traffic&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--delta_t&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;delta_t is a small time range during which the normal</span>
<span class="s">                behavior is considered unchanged&quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PeriodStaticDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStaticDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;start&#39;</span><span class="p">]</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">win_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">]</span>
        <span class="n">period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;period&#39;</span><span class="p">]</span>
        <span class="n">delta_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;delta_t&#39;</span><span class="p">]</span>

        <span class="n">rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">delta_t</span><span class="p">]</span>

        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">CombinedEM</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">norm_rg_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;normal_rg&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm_rg_ref</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">norm_rg_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)]</span>

        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">period</span>
        <span class="k">if</span> <span class="n">period</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;period is too large&#39;</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">norm_rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">period</span><span class="p">,</span> <span class="n">rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">period</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">norm_rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="n">norm_win_em</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span>
                        <span class="n">rg</span><span class="o">=</span><span class="n">norm_rg</span><span class="p">,</span>
                        <span class="n">rg_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">FetchNoDataException</span><span class="p">:</span>
                <span class="k">break</span> <span class="c">#FIXME</span>
            <span class="k">except</span> <span class="n">DataEndException</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_win_em</span> <span class="o">/</span> <span class="n">i</span>
        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_win_em</span><span class="o">.</span><span class="n">data</span>

        <span class="k">return</span> <span class="n">norm_win_em</span>
</div></div>
<span class="sd">&quot;&quot;&quot; The following part contains several algorithms that select normal emperical</span>
<span class="sd">measure in a novel way. They are designed to handle the case that the nominal</span>
<span class="sd">traffic itself is time-varying</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="DynamicStoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DynamicStoDetector">[docs]</a><span class="k">class</span> <span class="nc">DynamicStoDetector</span><span class="p">(</span><span class="n">FBAnoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Class for All Dynamic Stochasic Detector</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DynamicStoDetector.I"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DynamicStoDetector.I">[docs]</a>    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">d_pmf</span><span class="p">,</span> <span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span> <span class="o">=</span> <span class="n">em</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;em&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">em</span>
        <span class="n">pmf</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">I1</span><span class="p">(</span><span class="n">d_pmf</span><span class="p">,</span> <span class="n">pmf</span><span class="p">),</span> <span class="n">I2</span><span class="p">(</span><span class="n">d_Pmb</span><span class="p">,</span> <span class="n">d_mpmb</span><span class="p">,</span> <span class="n">Pmb</span><span class="p">,</span> <span class="n">mpmb</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DynamicStoDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DynamicStoDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
</div></div>
<div class="viewcode-block" id="TwoWindowAnoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.TwoWindowAnoDetector">[docs]</a><span class="k">class</span> <span class="nc">TwoWindowAnoDetector</span><span class="p">(</span><span class="n">DynamicStoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Two Window Stochastic Anomaly Detector.</span>
<span class="sd">    - A small window to capture the transient information</span>
<span class="sd">    - A relative long window as a reference traffic. This window</span>
<span class="sd">        should be properly chosen so that it can reflect the stationary</span>
<span class="sd">        property of the traffic.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TwoWindowAnoDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.TwoWindowAnoDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TwoWindowAnoDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">init_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--norm_win_ratio&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot; the ratio of normal window with the detection window size.</span>
<span class="s">                &quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TwoWindowAnoDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.TwoWindowAnoDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Use emperical measure of large window as nominal emperical measure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TwoWindowAnoDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">norm_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;norm_em&#39;</span><span class="p">]</span>
        <span class="n">norm_win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;norm_win_ratio&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="c"># st = self.rg[0] - norm_win_size if (self.rg[0] &gt; norm_win_size ) else 0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">norm_win_size</span><span class="p">:</span>
            <span class="n">norm_rg</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">norm_win_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">norm_win_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="n">norm_rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_em</span>

        <span class="k">return</span> <span class="n">norm_win_em</span>
</div></div>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">DataHandler</span> <span class="kn">import</span> <span class="n">CombinedEM</span>

<div class="viewcode-block" id="PeriodStoDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStoDetector">[docs]</a><span class="k">class</span> <span class="nc">PeriodStoDetector</span><span class="p">(</span><span class="n">DynamicStoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stochastic Detector Designed to Detect Anomaly when the</span>
<span class="sd">    normal behaviour change periodically. Only choose traffic periodically as normal traffic</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PeriodStoDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStoDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeriodStoDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">init_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--period&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;the period of underlying traffic&quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PeriodStoDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.PeriodStoDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeriodStoDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">StoDetector</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">norm_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;norm_em&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">CombinedEM</span><span class="p">(</span><span class="n">norm_em</span><span class="p">)</span>
        <span class="n">norm_rg_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;normal_rg&#39;</span><span class="p">]</span>
        <span class="n">period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;period&#39;</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">norm_em</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">period</span>
        <span class="k">if</span> <span class="n">period</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;period is too largw&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># norm_rg = [rg[0] + i * period, rg[1] + i * period] #FIXME need to look back</span>
                <span class="n">norm_rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">period</span><span class="p">,</span> <span class="n">rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">period</span><span class="p">]</span> <span class="c">#FIXME need to look back</span>
                <span class="k">if</span> <span class="n">norm_rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">norm_rg_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">break</span>
                <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_win_em</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="n">norm_rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="n">FetchNoDataException</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="n">DataEndException</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c">#FIXME</span>
                <span class="k">return</span>
        <span class="c"># j = 0</span>
        <span class="c"># while True:</span>
        <span class="c">#     i += 1</span>
        <span class="c">#     j -= 1</span>
        <span class="c">#     if rg[0] + j * period &lt; norm_rg_ref[0]:</span>
        <span class="c">#         break</span>
        <span class="c">#     try:</span>
        <span class="c">#         norm_rg = [rg[0] + j * period, rg[1] + j * period] #FIXME need to look back</span>
        <span class="c">#         norm_win_em = norm_win_em + self.get_em(rg=norm_rg, rg_type=self.desc[&#39;win_type&#39;])</span>
        <span class="c">#     except FetchNoDataException:</span>
        <span class="c">#         break</span>
        <span class="c">#     except DataEndException:</span>
        <span class="c">#         break</span>

        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_win_em</span> <span class="o">/</span> <span class="n">i</span>
        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="n">norm_win_em</span><span class="o">.</span><span class="n">data</span>

        <span class="k">return</span> <span class="n">norm_win_em</span>

    <span class="c"># def plot(self, *args, **kwargs):</span>
    <span class="c">#     rt = self.record_data[&#39;winT&#39;]</span>
    <span class="c">#     ep = self.record_data[&#39;entropy&#39;]</span>
    <span class="c">#     i = -1</span>
    <span class="c">#     for v in rt:</span>
    <span class="c">#         i += 1</span>
    <span class="c">#         if v &gt; 3000:</span>
    <span class="c">#             break</span>
    <span class="c">#     threshold = self.record_data[&#39;threshold&#39;]</span>
    <span class="c">#     plot_points(rt[:i], ep[:i], threshold,</span>
    <span class="c">#             xlabel_=self.desc[&#39;win_type&#39;], ylabel_= &#39;entropy&#39;,</span>
    <span class="c">#             *args, **kwargs)</span>

</div></div>
<div class="viewcode-block" id="DummyShiftWindowDetector"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DummyShiftWindowDetector">[docs]</a><span class="k">class</span> <span class="nc">DummyShiftWindowDetector</span><span class="p">(</span><span class="n">DynamicStoDetector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; For data in window i, simply using the data in widnow i-shift to</span>
<span class="sd">    calculate norm_em</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DummyShiftWindowDetector.init_parser"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DummyShiftWindowDetector.init_parser">[docs]</a>    <span class="k">def</span> <span class="nf">init_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--shift&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s">&quot;&quot;&quot;shift for the window used as reference traffic&quot;&quot;&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="DummyShiftWindowDetector.cal_norm_em"><a class="viewcode-back" href="../../../generated/sadit.Detector.html#sadit.Detector.StoDetector.DummyShiftWindowDetector.cal_norm_em">[docs]</a>    <span class="k">def</span> <span class="nf">cal_norm_em</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; For data in window *i*, simply using the data in widnow *i-shift* to</span>
<span class="sd">        calculate norm_em</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DummyShiftWindowDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">cal_norm_em</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">win_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_size&#39;</span><span class="p">]</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;shift&#39;</span><span class="p">]</span>
        <span class="k">assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">win_size</span><span class="p">)</span>
        <span class="n">norm_rg</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span> <span class="o">*</span> <span class="n">win_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span> <span class="o">*</span> <span class="n">win_size</span><span class="p">]</span>
        <span class="c"># import pdb;pdb.set_trace()</span>
        <span class="n">norm_win_em</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_em</span><span class="p">(</span><span class="n">rg</span><span class="o">=</span><span class="n">norm_rg</span><span class="p">,</span> <span class="n">rg_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">[</span><span class="s">&#39;win_type&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">norm_win_em</span>
</div></div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">find_seg</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;res, &#39;</span><span class="p">,</span> <span class="n">res</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">flag</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">b</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&#39;flag, &#39;</span><span class="p">,</span> <span class="n">f</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SADIT 1.1.0 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sadit.html" >sadit</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Jing Conan Wang.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>